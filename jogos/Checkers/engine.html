<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Checkers Engine</title>
</head>
<body>
    <script>
        // Checkers Engine JavaScript Implementation
        // Based on the Checkers-Engine Python implementation
        
        class CheckersEngine {
            constructor() {
                this.board = this.initializeBoard();
                this.difficultySettings = {
                    1: { depth: 1, time: 300, useQuiescence: false },   // Iniciante
                    2: { depth: 2, time: 500, useQuiescence: false },   // Fácil
                    3: { depth: 3, time: 800, useQuiescence: false },  // Básico
                    4: { depth: 4, time: 1000, useQuiescence: false },  // Simples
                    5: { depth: 5, time: 1200, useQuiescence: true },  // Razoável
                    6: { depth: 6, time: 1500, useQuiescence: true },  // Médio
                    7: { depth: 7, time: 1800, useQuiescence: true },  // Intermediário
                    8: { depth: 8, time: 2000, useQuiescence: true },  // Avançado
                    9: { depth: 9, time: 2200, useQuiescence: true },   // Experiente
                    10: { depth: 10, time: 2500, useQuiescence: true }, // Habilidoso
                    11: { depth: 11, time: 2800, useQuiescence: true }, // Profissional
                    12: { depth: 12, time: 3000, useQuiescence: true }, // Expert
                    13: { depth: 13, time: 3200, useQuiescence: true }, // Mestre
                    14: { depth: 14, time: 3500, useQuiescence: true }, // Grande Mestre
                    15: { depth: 15, time: 4000, useQuiescence: true }  // Lenda
                };
            }
            
            initializeBoard() {
                return [
                    [0, 2, 0, 2, 0, 2, 0, 2],
                    [2, 0, 2, 0, 2, 0, 2, 0],
                    [0, 2, 0, 2, 0, 2, 0, 2],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [0, 0, 0, 0, 0, 0, 0, 0],
                    [1, 0, 1, 0, 1, 0, 1, 0],
                    [0, 1, 0, 1, 0, 1, 0, 1],
                    [1, 0, 1, 0, 1, 0, 1, 0]
                ];
            }
            
            // Converte string do tabuleiro para matriz
            parseBoardString(boardStr) {
                try {
                    const board = JSON.parse(boardStr);
                    if (Array.isArray(board) && board.length === 8) {
                        return board;
                    }
                } catch (e) {
                    console.error('Erro ao parsear board string:', e);
                }
                return this.initializeBoard();
            }
            
            // Converte matriz para string
            boardToString(board) {
                return JSON.stringify(board);
            }
            
            // Verifica se é uma peça do jogador
            isPlayerPiece(piece, player) {
                if (player === 1) {
                    return piece === 1 || piece === 3; // Peça vermelha ou dama vermelha
                } else {
                    return piece === 2 || piece === 4; // Peça azul ou dama azul
                }
            }
            
            // Verifica se é uma peça inimiga
            isEnemyPiece(piece, player) {
                if (player === 1) {
                    return piece === 2 || piece === 4; // Peça azul ou dama azul
                } else {
                    return piece === 1 || piece === 3; // Peça vermelha ou dama vermelha
                }
            }
            
            // Gera movimentos possíveis para uma peça (incluindo capturas múltiplas)
            generateMovesForPiece(board, x, y, player) {
                const moves = [];
                const piece = board[y][x];
                
                if (!this.isPlayerPiece(piece, player)) {
                    return moves;
                }
                
                const isKing = piece === 3 || piece === 4;
                const directions = isKing ? 
                    [[-1, -1], [-1, 1], [1, -1], [1, 1]] : // Dama pode mover em todas as direções
                    (player === 1 ? [[-1, -1], [-1, 1]] : [[1, -1], [1, 1]]); // Peças normais
                
                // Primeiro, verifica se há capturas possíveis
                const captureMoves = this.generateCaptureMoves(board, x, y, player, directions);
                if (captureMoves.length > 0) {
                    return captureMoves; // Se há capturas, elas são obrigatórias
                }
                
                // Se não há capturas, gera movimentos regulares
                for (const [dx, dy] of directions) {
                    const newX = x + dx;
                    const newY = y + dy;
                    
                    if (this.isValidPosition(newX, newY) && board[newY][newX] === 0) {
                        moves.push({ from: { x, y }, to: { x: newX, y: newY }, type: 'move' });
                    }
                }
                
                return moves;
            }
            
            // Gera capturas múltiplas recursivamente
            generateCaptureMoves(board, x, y, player, directions) {
                const captureMoves = [];
                const piece = board[y][x];
                const isKing = piece === 3 || piece === 4;
                
                for (const [dx, dy] of directions) {
                    const middleX = x + dx;
                    const middleY = y + dy;
                    const jumpX = x + 2 * dx;
                    const jumpY = y + 2 * dy;
                    
                    if (this.isValidPosition(jumpX, jumpY) && this.isValidPosition(middleX, middleY)) {
                        const middlePiece = board[middleY][middleX];
                        
                        if (this.isEnemyPiece(middlePiece, player) && board[jumpY][jumpX] === 0) {
                            // Cria uma captura simples
                            const simpleCapture = { 
                                from: { x, y }, 
                                to: { x: jumpX, y: jumpY }, 
                                type: 'capture',
                                captures: [{ x: middleX, y: middleY }]
                            };
                            captureMoves.push(simpleCapture);
                            
                            // Verifica se há mais capturas possíveis a partir da nova posição
                            const newBoard = this.makeMove(board, simpleCapture);
                            const additionalCaptures = this.generateCaptureMoves(newBoard, jumpX, jumpY, player, directions);
                            
                            // Adiciona capturas múltiplas
                            for (const additionalCapture of additionalCaptures) {
                                const multipleCapture = {
                                    from: { x, y },
                                    to: additionalCapture.to,
                                    type: 'capture',
                                    captures: [{ x: middleX, y: middleY }, ...additionalCapture.captures]
                                };
                                captureMoves.push(multipleCapture);
                            }
                        }
                    }
                }
                
                return captureMoves;
            }
            
            // Gera todos os movimentos possíveis para um jogador
            generateAllMoves(board, player) {
                const moves = [];
                const captureMoves = [];
                
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        const pieceMoves = this.generateMovesForPiece(board, x, y, player);
                        
                        for (const move of pieceMoves) {
                            if (move.type === 'capture') {
                                captureMoves.push(move);
                            } else {
                                moves.push(move);
                            }
                        }
                    }
                }
                
                // Se há capturas, elas são obrigatórias
                return captureMoves.length > 0 ? captureMoves : moves;
            }
            
            // Verifica se a posição é válida
            isValidPosition(x, y) {
                return x >= 0 && x < 8 && y >= 0 && y < 8;
            }
            
            // Avalia o tabuleiro (otimizada)
            evaluateBoard(board, player) {
                let score = 0;
                const opponent = player === 1 ? 2 : 1;
                
                for (let y = 0; y < 8; y++) {
                    for (let x = 0; x < 8; x++) {
                        const piece = board[y][x];
                        
                        if (piece === player) {
                            score += 10; // Peça normal
                            // Bonus de posição
                            const centerDistance = Math.abs(x - 3.5) + Math.abs(y - 3.5);
                            score += (7 - centerDistance) * 0.2;
                        } else if (piece === player + 2) {
                            score += 30; // Dama
                        } else if (piece === opponent) {
                            score -= 10; // Peça inimiga
                        } else if (piece === opponent + 2) {
                            score -= 30; // Dama inimiga
                        }
                    }
                }
                
                return score;
            }
            
            // Algoritmo minimax com alpha-beta pruning
            // Algoritmo minimax otimizado com poda alfa-beta e controle de tempo
            minimax(board, depth, alpha, beta, maximizingPlayer, player, startTime, timeLimit) {
                // Verifica se o tempo limite foi atingido
                if (Date.now() - startTime > timeLimit) {
                    return this.evaluateBoard(board, player);
                }
                
                if (depth === 0) {
                    return this.evaluateBoard(board, player);
                }
                
                const moves = this.generateAllMoves(board, maximizingPlayer ? player : (player === 1 ? 2 : 1));
                
                if (moves.length === 0) {
                    return this.evaluateBoard(board, player);
                }
                
                // Ordena movimentos para melhorar a poda (capturas primeiro)
                moves.sort((a, b) => {
                    if (a.type === 'capture' && b.type !== 'capture') return -1;
                    if (a.type !== 'capture' && b.type === 'capture') return 1;
                    return 0;
                });
                
                if (maximizingPlayer) {
                    let maxEval = -Infinity;
                    for (const move of moves) {
                        const newBoard = this.makeMove(board, move);
                        const eval = this.minimax(newBoard, depth - 1, alpha, beta, false, player, startTime, timeLimit);
                        maxEval = Math.max(maxEval, eval);
                        alpha = Math.max(alpha, eval);
                        if (beta <= alpha) break;
                    }
                    return maxEval;
                } else {
                    let minEval = Infinity;
                    for (const move of moves) {
                        const newBoard = this.makeMove(board, move);
                        const eval = this.minimax(newBoard, depth - 1, alpha, beta, true, player, startTime, timeLimit);
                        minEval = Math.min(minEval, eval);
                        beta = Math.min(beta, eval);
                        if (beta <= alpha) break;
                    }
                    return minEval;
                }
            }
            
            // Faz um movimento no tabuleiro (suporta capturas múltiplas)
            makeMove(board, move) {
                const newBoard = board.map(row => [...row]);
                const { from, to, type, captures } = move;
                
                const piece = newBoard[from.y][from.x];
                newBoard[from.y][from.x] = 0;
                newBoard[to.y][to.x] = piece;
                
                // Se é captura, remove todas as peças capturadas
                if (type === 'capture' && captures) {
                    for (const capture of captures) {
                        newBoard[capture.y][capture.x] = 0;
                    }
                } else if (type === 'capture') {
                    // Fallback para captura simples (compatibilidade)
                    const middleX = (from.x + to.x) / 2;
                    const middleY = (from.y + to.y) / 2;
                    newBoard[middleY][middleX] = 0;
                }
                
                // Verifica promoção a dama
                if (piece === 1 && to.y === 0) {
                    newBoard[to.y][to.x] = 3; // Dama vermelha
                } else if (piece === 2 && to.y === 7) {
                    newBoard[to.y][to.x] = 4; // Dama azul
                }
                
                return newBoard;
            }
            
            // Encontra o melhor movimento (otimizado com controle de tempo)
            getBestMove(boardStr, difficulty) {
                const startTime = Date.now();
                const board = this.parseBoardString(boardStr);
                const player = 2; // Bot sempre joga com as azuis
                const settings = this.difficultySettings[difficulty] || this.difficultySettings[2];
                
                console.log(`🚀 ENGINE: Iniciando busca com profundidade ${settings.depth}, tempo limite ${settings.time}ms`);
                
                const moves = this.generateAllMoves(board, player);
                
                if (moves.length === 0) {
                    return JSON.stringify({ error: 'No moves available' });
                }
                
                // Prioriza capturas múltiplas (sempre obrigatórias)
                const captureMoves = moves.filter(move => move.type === 'capture');
                if (captureMoves.length > 0) {
                    // Ordena por número de capturas (mais capturas = melhor)
                    captureMoves.sort((a, b) => {
                        const aCaptures = a.captures ? a.captures.length : 1;
                        const bCaptures = b.captures ? b.captures.length : 1;
                        return bCaptures - aCaptures;
                    });
                    
                    // Escolhe a captura com mais peças capturadas
                    const bestCapture = captureMoves[0];
                    console.log(`🎯 ENGINE: Escolhendo captura múltipla com ${bestCapture.captures ? bestCapture.captures.length : 1} peças`);
                    
                    const result = {
                        fromRow: bestCapture.from.y,
                        fromCol: bestCapture.from.x,
                        toRow: bestCapture.to.y,
                        toCol: bestCapture.to.x,
                        type: bestCapture.type,
                        captures: bestCapture.captures || [{ x: (bestCapture.from.x + bestCapture.to.x) / 2, y: (bestCapture.from.y + bestCapture.to.y) / 2 }]
                    };
                    
                    return JSON.stringify(result);
                }
                
                // Se não há capturas, usa busca otimizada para movimento regular
                let bestMove = moves[0];
                let bestScore = -Infinity;
                
                if (settings.depth >= 8) {
                    // Para níveis altos, usa busca iterativa
                    console.log(`🔍 ENGINE: Usando busca iterativa para nível alto`);
                    const result = this.iterativeSearch(board, player, settings.depth, settings.time);
                    bestMove = result.move || moves[0];
                    bestScore = result.score;
                } else {
                    // Para níveis baixos, usa busca direta otimizada
                    console.log(`⚡ ENGINE: Usando busca direta para nível baixo`);
                    
                    // Ordena movimentos para melhorar a busca
                    moves.sort((a, b) => {
                        const aScore = this.evaluateMove(board, a, player);
                        const bScore = this.evaluateMove(board, b, player);
                        return bScore - aScore;
                    });
                    
                    // Limita o número de movimentos analisados para economizar tempo
                    const maxMovesToAnalyze = Math.min(moves.length, settings.depth <= 5 ? moves.length : 6);
                    
                    for (let i = 0; i < maxMovesToAnalyze; i++) {
                        const move = moves[i];
                        const newBoard = this.makeMove(board, move);
                        const score = this.minimax(newBoard, settings.depth - 1, -Infinity, Infinity, false, player, startTime, settings.time);
                        
                        if (score > bestScore) {
                            bestScore = score;
                            bestMove = move;
                        }
                        
                        // Verifica se o tempo limite foi atingido
                        if (Date.now() - startTime > settings.time) {
                            console.log(`⏰ ENGINE: Tempo limite atingido após ${i + 1} movimentos analisados`);
                            break;
                        }
                    }
                }
                
                const elapsedTime = Date.now() - startTime;
                console.log(`✅ ENGINE: Movimento escolhido em ${elapsedTime}ms, score: ${bestScore}`);
                
                // Converte para formato compatível com Flutter
                const result = {
                    fromRow: bestMove.from.y,
                    fromCol: bestMove.from.x,
                    toRow: bestMove.to.y,
                    toCol: bestMove.to.x,
                    type: bestMove.type
                };
                
                return JSON.stringify(result);
            }
            
            // Avalia um movimento individual (heurística rápida)
            evaluateMove(board, move, player) {
                const newBoard = this.makeMove(board, move);
                return this.evaluateBoard(newBoard, player);
            }
            
            // Busca iterativa para melhorar performance
            iterativeSearch(board, player, maxDepth, timeLimit) {
                const startTime = Date.now();
                let bestMove = null;
                let bestScore = -Infinity;
                
                // Começa com profundidade 1 e vai aumentando
                for (let depth = 1; depth <= maxDepth; depth++) {
                    if (Date.now() - startTime > timeLimit * 0.8) {
                        console.log(`⏰ ENGINE: Tempo limite atingido na profundidade ${depth}`);
                        break;
                    }
                    
                    const moves = this.generateAllMoves(board, player);
                    if (moves.length === 0) break;
                    
                    let currentBestMove = moves[0];
                    let currentBestScore = -Infinity;
                    
                    for (const move of moves) {
                        const newBoard = this.makeMove(board, move);
                        const score = this.minimax(newBoard, depth - 1, -Infinity, Infinity, false, player, startTime, timeLimit);
                        
                        if (score > currentBestScore) {
                            currentBestScore = score;
                            currentBestMove = move;
                        }
                        
                        if (Date.now() - startTime > timeLimit * 0.8) break;
                    }
                    
                    if (currentBestScore > bestScore) {
                        bestScore = currentBestScore;
                        bestMove = currentBestMove;
                    }
                    
                    console.log(`🔍 ENGINE: Profundidade ${depth} completada, melhor score: ${currentBestScore}`);
                }
                
                return { move: bestMove, score: bestScore };
            }
        }
        
        // Instância global da engine
        const checkersEngine = new CheckersEngine();
        
        // Função global para o Flutter chamar
        function getBestMove(boardStr, difficulty) {
            try {
                console.log('🎯 ENGINE: getBestMove chamado com boardStr:', boardStr, 'difficulty:', difficulty);
                
                // Verifica se a engine existe
                if (typeof checkersEngine === 'undefined') {
                    console.error('❌ ENGINE: checkersEngine não está definida');
                    return JSON.stringify({ error: 'Engine não inicializada' });
                }
                
                // Verifica se a função existe
                if (typeof checkersEngine.getBestMove !== 'function') {
                    console.error('❌ ENGINE: getBestMove não é uma função');
                    return JSON.stringify({ error: 'Função getBestMove não encontrada' });
                }
                
                const result = checkersEngine.getBestMove(boardStr, difficulty);
                console.log('🎯 ENGINE: Resultado:', result);
                return result;
            } catch (error) {
                console.error('❌ ENGINE: Erro na engine:', error);
                return JSON.stringify({ error: error.message });
            }
        }
        
        // Função para testar a engine
        function testEngine() {
            try {
                console.log('🧪 TESTE: Iniciando teste da engine...');
                
                // Testa se a engine existe
                if (typeof checkersEngine === 'undefined') {
                    console.error('❌ TESTE: checkersEngine não existe');
                    return 'ERROR: Engine não encontrada';
                }
                
                // Testa se a função existe
                if (typeof checkersEngine.getBestMove !== 'function') {
                    console.error('❌ TESTE: getBestMove não é uma função');
                    return 'ERROR: Função getBestMove não encontrada';
                }
                
                // Testa com tabuleiro inicial
                const testBoard = JSON.stringify(checkersEngine.initializeBoard());
                console.log('🧪 TESTE: Tabuleiro de teste:', testBoard);
                
                // Testa com dificuldade 3 (difícil)
                const result = getBestMove(testBoard, 3);
                console.log('🧪 TESTE: Resultado do teste:', result);
                
                return result;
            } catch (error) {
                console.error('❌ TESTE: Erro no teste:', error);
                return 'ERROR: ' + error.message;
            }
        }
        
        // Função simples para testar se a engine está funcionando
        function simpleTest() {
            try {
                console.log('🔧 SIMPLE TEST: Testando engine básica...');
                
                // Testa se a engine existe
                if (typeof checkersEngine === 'undefined') {
                    return 'ERROR: Engine não encontrada';
                }
                
                // Testa se a função existe
                if (typeof checkersEngine.getBestMove !== 'function') {
                    return 'ERROR: Função getBestMove não encontrada';
                }
                
                // Testa com tabuleiro inicial
                const testBoard = JSON.stringify(checkersEngine.initializeBoard());
                console.log('🔧 SIMPLE TEST: Tabuleiro:', testBoard);
                
                // Testa com dificuldade 2 (médio) para teste rápido
                const result = getBestMove(testBoard, 2);
                console.log('🔧 SIMPLE TEST: Resultado:', result);
                
                return result;
            } catch (error) {
                console.error('❌ SIMPLE TEST: Erro:', error);
                return 'ERROR: ' + error.message;
            }
        }
        
        // Log de inicialização
        console.log('Checkers Engine carregada e pronta!');
    </script>
</body>
</html>
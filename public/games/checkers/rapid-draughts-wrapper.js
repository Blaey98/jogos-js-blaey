// Wrapper para expor rapid-draughts no window
(function() {
    // Simula o ambiente Node.js para o rapid-draughts
    const module = { exports: {} };
    const exports = module.exports;
    
    // Carrega o rapid-draughts
    const rapidDraughtsCode = `
    "use strict";var G=Object.defineProperty;var b=(r,t,n)=>t in r?G(r,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):r[t]=n;var l=(r,t,n)=>b(r,typeof t!="symbol"?t+"":t,n);Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const c=require("./index-cMcgHLGu.cjs"),e={and(...r){return r.reduce((t,n)=>t&n,4294967295)>>>0},or(...r){return r.reduce((t,n)=>t|n,0)>>>0},xor(r,t){return(r^t)>>>0},not(r){return~r>>>0},rotLeft(r,t){const n=t&31;return(r<<n|r>>>32-n)>>>0},rotRight(r,t){const n=t&31;return(r>>>n|r<<32-n)>>>0},cardinality(r){let t=r;return t=t-(t>>>1&1431655765),t=(t&858993459)+(t>>>2&858993459),(t+(t>>>4)&252645135)*16843009>>>24},decompose(r){const t=[];let n=r;for(let s=1;n;s<<=1)n&s&&(t.push(s>>>0),n^=s);return t}};function M(r,t){return r.origin===t.origin&&r.destination===t.destination&&r.captures===t.captures}function H(r){const t=Math.floor(Math.sqrt(r.length)),n="-".repeat(1+t*4);let s=\`\${n}
    \`;for(const[i,o]of r.entries()){if(i%t===0&&(s+="|"),o.piece){let u=o.piece.player===c.DraughtsPlayer.LIGHT?"x":"o";u=o.piece.king?u.toUpperCase():u,s+=\` \${u} |\`}else s+="   |";i%t===t-1&&(s+=\` 
    \${n}
    \`)}return s}class C{constructor(t,n,s){l(this,"engine");l(this,"history");l(this,"_board");l(this,"_moves");l(this,"adapter");this.engine=t,this.history=n,this.adapter=s}get status(){return this.engine.status}get player(){return this.engine.data.player}get board(){return this._board??(this._board=this.adapter.toBoard1D(this.engine.data.board))}get moves(){return this._moves??(this._moves=this.engine.moves.map(t=>this.adapter.toMove1D(t)))}isValidMove(t){const n=this.adapter.toEngineMove(t);return this.engine.isValidMove(n)}move(t){if(!this.isValidMove(t))throw new Error(\`invalid move: \${JSON.stringify(t)}\`);this.history.boards.push(this.board),this.history.moves.push(t);const n=this.adapter.toEngineMove(t);this.engine.move(n),this._board=void 0,this._moves=void 0}asciiBoard(){return H(this.board)}}const S=32,a=[];a[0]=1;for(let r=1;r<S;r++)a[r]=a[r-1]*2;const m=a[18]|a[12]|a[6]|a[0],P=a[19]|a[13]|a[7]|a[1],B=a[26]|a[20]|a[14]|a[8];a[27]|a[21]|a[15]|a[9];a[2]|a[28]|a[22]|a[16];const x=a[3]|a[29]|a[23]|a[17],U=a[10]|a[4]|a[30]|a[24],R=a[11]|a[5]|a[31]|a[25],A=a[18]|a[26]|a[2]|a[10],E=a[1]|a[9]|a[17]|a[25],J=~(R|A),V=~(R|E),$=~(m|A),Y=~(m|E),q=m|P|B,j=x|U|R,z=a[21]|a[28]|a[22],Q=a[29]|a[22]|a[21]|a[14],d={RANK_0:m,RANK_7:R,FORWARD_LEFT:J,FORWARD_RIGHT:V,BACKWARD_LEFT:$,BACKWARD_RIGHT:Y,LIGHT_START:q,DARK_START:j,MIDDLE_FOUR_RANK_TWO_FILE:Q,MIDDLE_TWO_RANK_FOUR_FILE:z};class _{constructor(t){l(this,"intermediates");this.intermediates=t}getJumpers(){let t=e.and(e.rotRight(this.intermediates.empty,7),e.and(this.intermediates.opponent,d.FORWARD_LEFT)),n=e.and(e.rotRight(t,7),e.and(this.intermediates.forward,d.FORWARD_LEFT));return t=e.and(e.rotRight(this.intermediates.empty,1),e.and(this.intermediates.opponent,d.FORWARD_RIGHT)),n=e.or(n,e.and(e.rotRight(t,1),e.and(this.intermediates.forward,d.FORWARD_RIGHT))),t=e.and(e.rotLeft(this.intermediates.empty,1),e.and(this.intermediates.opponent,d.BACKWARD_LEFT)),n=e.or(n,e.and(e.rotLeft(t,1),e.and(this.intermediates.backward,d.BACKWARD_LEFT))),t=e.and(e.rotLeft(this.intermediates.empty,7),e.and(this.intermediates.opponent,d.BACKWARD_RIGHT)),n=e.or(n,e.and(e.rotLeft(t,7),e.and(this.intermediates.backward,d.BACKWARD_RIGHT))),n}getMovers(){let t=0;return this.intermediates.forward&&(t=e.or(t,e.and(e.and(e.rotRight(this.intermediates.empty,7),this.intermediates.forward),d.FORWARD_LEFT)),t=e.or(t,e.and(e.and(e.rotRight(this.intermediates.empty,1),this.intermediates.forward),d.FORWARD_RIGHT))),this.intermediates.backward&&(t=e.or(t,e.and(e.and(e.rotLeft(this.intermediates.empty,1),this.intermediates.backward),d.BACKWARD_LEFT)),t=e.or(t,e.and(e.and(e.rotLeft(this.intermediates.empty,7),this.intermediates.backward),d.BACKWARD_RIGHT))),t}getMovesFromOrigin(t){const n=[];if(e.and(t,this.intermediates.forward)){const s=e.and(e.rotLeft(e.and(t,d.FORWARD_LEFT),7),this.intermediates.empty);s&&n.push({origin:t,destination:s,captures:0});const i=e.and(e.rotLeft(e.and(t,d.FORWARD_RIGHT),1),this.intermediates.empty);i&&n.push({origin:t,destination:i,captures:0})}if(e.and(t,this.intermediates.backward)){const s=e.and(e.rotRight(e.and(t,d.BACKWARD_LEFT),1),this.intermediates.empty);s&&n.push({origin:t,destination:s,captures:0});const i=e.and(e.rotRight(e.and(t,d.BACKWARD_RIGHT),7),this.intermediates.empty);i&&n.push({origin:t,destination:i,captures:0})}return n}getJumpsFromOrigin(t){const n=this.getSingleJumpFromOrigin(t),s=[];for(;n.length>0;){const i=n.pop();if(i===void 0)break;const u=this.applyUnfinishedCapture({...i,origin:t}).getSingleJumpFromOrigin(i.destination);for(const h of u)n.push({origin:t,destination:h.destination,captures:e.or(i.captures,h.captures)});u.length===0&&s.push(i)}return s}getSingleJumpFromOrigin(t){const n=[];if(e.and(t,this.intermediates.forward)){const s=e.and(e.rotLeft(e.and(t,d.FORWARD_LEFT),7),this.intermediates.opponent),i=e.and(e.rotLeft(e.and(s,d.FORWARD_LEFT),7),this.intermediates.empty);i&&n.push({origin:t,destination:i,captures:s});const o=e.and(e.rotLeft(e.and(t,d.FORWARD_RIGHT),1),this.intermediates.opponent),u=e.and(e.rotLeft(e.and(o,d.FORWARD_RIGHT),1),this.intermediates.empty);u&&n.push({origin:t,destination:u,captures:o})}if(e.and(t,this.intermediates.backward)){const s=e.and(e.rotRight(e.and(t,d.BACKWARD_LEFT),1),this.intermediates.opponent),i=e.and(e.rotRight(e.and(s,d.BACKWARD_LEFT),1),this.intermediates.empty);i&&n.push({origin:t,destination:i,captures:s});const o=e.and(e.rotRight(e.and(t,d.BACKWARD_RIGHT),7),this.intermediates.opponent),u=e.and(e.rotRight(e.and(o,d.BACKWARD_RIGHT),7),this.intermediates.empty);u&&n.push({origin:t,destination:u,captures:o})}return n}applyUnfinishedCapture(t){return new _({forward:e.and(this.intermediates.forward,t.origin)?e.or(this.intermediates.forward,t.destination):this.intermediates.forward,backward:e.and(this.intermediates.backward,t.origin)?e.or(this.intermediates.backward,t.destination):this.intermediates.backward,opponent:e.and(this.intermediates.opponent,e.not(t.captures)),empty:this.intermediates.empty})}}const X={fromEngine(r){const{player:t,board:n}=r.data;return new _({forward:t===c.DraughtsPlayer.LIGHT?n.light:e.and(n.dark,n.king),backward:t===c.DraughtsPlayer.LIGHT?e.and(n.light,n.king):n.dark,opponent:t===c.DraughtsPlayer.LIGHT?n.dark:n.light,empty:e.not(e.or(n.light,n.dark))})}},Z={player:c.DraughtsPlayer.DARK,board:{light:d.LIGHT_START,dark:d.DARK_START,king:0},stats:{sinceCapture:0,sinceNonKingAdvance:0}},tt={status(r){return r.moves.length===0?r.data.player===c.DraughtsPlayer.LIGHT?c.DraughtsStatus.DARK_WON:c.DraughtsStatus.LIGHT_WON:r.data.stats.sinceCapture>=40&&r.data.stats.sinceNonKingAdvance>=40?c.DraughtsStatus.DRAW:c.DraughtsStatus.PLAYING},isValidMove(r,t){return r.moves.some(n=>M(t,n))},moves(r){const t=X.fromEngine(r),n=[],s=t.getJumpers();if(s){for(const o of e.decompose(s))n.push(...t.getJumpsFromOrigin(o));return n}const i=t.getMovers();for(const o of e.decompose(i))n.push(...t.getMovesFromOrigin(o));return n},move(r,t){if(!r.isValidMove(t))throw new Error(\`invalid move: \${JSON.stringify(t)}\`);const n={...r.data.board},s={...r.data.stats},i=e.and(t.origin,r.data.board.king),o=e.not(e.or(t.origin,t.captures));return n.light=e.and(n.light,o),n.dark=e.and(n.dark,o),n.king=e.and(n.king,o),e.and(t.origin,r.data.board.light)?n.light=e.or(n.light,t.destination):n.dark=e.or(n.dark,t.destination),i&&(n.king=e.or(n.king,t.destination)),n.king=e.or(n.king,e.and(t.destination,e.or(d.RANK_0,d.RANK_7))),e.and(t.destination,r.data.board.king)?(n.king=e.or(n.king,t.destination),s.sinceNonKingAdvance=0):s.sinceNonKingAdvance+=1,t.captures?s.sinceCapture=0:s.sinceCapture+=1,{player:r.data.player===c.DraughtsPlayer.LIGHT?c.DraughtsPlayer.DARK:c.DraughtsPlayer.LIGHT,board:n,stats:s}}},T={setup(r){return new c.DraughtsEngine({...Z,...r},tt)}},g=[a[11],a[5],a[31],a[25],a[10],a[4],a[30],a[24],a[3],a[29],a[23],a[17],a[2],a[28],a[22],a[16],a[27],a[21],a[15],a[9],a[26],a[20],a[14],a[8],a[19],a[13],a[7],a[1],a[18],a[12],a[6],a[0]],f=new Map(g.map((r,t)=>[r,t])),D={toMove1D(r){const t=f.get(r.origin);if(t===void 0)throw new Error(\`invalid move origin: \${r.origin}\`);const n=f.get(r.destination);if(n===void 0)throw new Error(\`invalid move destination: \${r.destination}\`);const s=[];for(const i of e.decompose(r.captures)){const o=f.get(i);o!==void 0&&s.push(o)}return{origin:t,destination:n,captures:s}},toEngineMove(r){const t=g[r.origin];if(t===void 0)throw new Error(\`invalid move origin: \${r.origin}\`);const n=g[r.destination];if(n===void 0)throw new Error(\`invalid move destination: \${r.destination}\`);let s=0;for(const i of r.captures){const o=g[i];if(o===void 0)throw new Error(\`invalid move capture: \${i}\`);s|=o}return{origin:t,destination:n,captures:s}},toBoard1D(r){const t=[];for(const[n,s]of g.entries()){Math.floor(n/4)%2===0&&t.push({dark:!1,piece:void 0,position:void 0});const i=!!(s&r.light),o=!!(s&r.dark),u=!!(s&r.king);t.push({dark:!0,position:n,piece:i||o?{player:i?c.DraughtsPlayer.LIGHT:c.DraughtsPlayer.DARK,king:u}:void 0}),Math.floor(n/4)%2!==0&&t.push({dark:!1,piece:void 0,position:void 0})}return t}},et={moves:[],boards:[]},nt={setup(r,t){const n=T.setup(r);return new C(n,{...et,...t},D)}},y={setup({adapter:r,strategy:t,options:n}){return async s=>{const i=await t({options:n,engine:s.engine});return r.toMove1D(i)}}};async function rt({options:{maxDepth:r,evaluationFunction:t,quiescence:n=!0},engine:s}){let i=Number.NEGATIVE_INFINITY,o;for(const u of s.moves){const h=s.clone();h.move(u);const p=-await I({data:{engine:h,alpha:Number.NEGATIVE_INFINITY,beta:Number.POSITIVE_INFINITY,depth:r-1},options:{evaluationFunction:t,quiescence:n}});p>=i&&(i=p,o=u)}if(o===void 0)throw new Error("no available moves");return o}async function I({data:{engine:r,alpha:t,beta:n,depth:s},options:{evaluationFunction:i,quiescence:o}}){if(s===0)return o?F({data:{engine:r,alpha:t,beta:n},options:{evaluationFunction:i}}):i(r);for(const u of r.moves){const h=r.clone();h.move(u);const p=-await I({data:{engine:h,alpha:-n,beta:-t,depth:s-1},options:{evaluationFunction:i,quiescence:o}});if(p>=n)return n;t=Math.max(p,t)}return t}async function F({data:{engine:r,alpha:t,beta:n},options:{evaluationFunction:s}}){const i=s(r);if(i>=n)return n;t=Math.max(i,t);for(const o of r.moves){if(!o.captures)continue;const u=r.clone();u.move(o);const h=-await F({data:{engine:u,alpha:-n,beta:-t},options:{evaluationFunction:s}});if(h>=n)return n;t=Math.max(h,t)}return t}async function at({engine:r}){if(r.moves.length===0)throw new Error("no valid moves");const t=Math.floor(Math.random()*r.moves.length);return r.moves[t]}const st={[c.DraughtsStatus.LIGHT_WON]:c.DraughtsPlayer.LIGHT,[c.DraughtsStatus.DARK_WON]:c.DraughtsPlayer.DARK},it=r=>{const t=r.status;return t!==c.DraughtsStatus.PLAYING?t===c.DraughtsStatus.DRAW?Number.NEGATIVE_INFINITY:r.data.player===st[t]?Number.POSITIVE_INFINITY:Number.NEGATIVE_INFINITY:pt(r)},ot=50,dt=77,ct=40,ut=25,ht=5;function pt(r){const t=r.data.player===c.DraughtsPlayer.LIGHT?r.data.board.light:r.data.board.dark,n=r.data.player===c.DraughtsPlayer.LIGHT?r.data.board.dark:r.data.board.dark,s=t&r.data.board.king,i=n&r.data.board.king,o=r.data.player===c.DraughtsPlayer.LIGHT?d.RANK_0:d.RANK_7,u=r.data.player===c.DraughtsPlayer.LIGHT?d.RANK_7:d.RANK_0,h=e.cardinality(t),p=e.cardinality(n),v=e.cardinality(s),L=e.cardinality(i),w=e.cardinality(t&o),k=e.cardinality(n&u),N=e.cardinality(t&d.MIDDLE_TWO_RANK_FOUR_FILE),K=e.cardinality(n&d.MIDDLE_TWO_RANK_FOUR_FILE),O=e.cardinality(t&d.MIDDLE_FOUR_RANK_TWO_FILE),W=e.cardinality(n&d.MIDDLE_FOUR_RANK_TWO_FILE);return(h-p)*ot+(v-L)*dt+(w-k)*ct+(N-K)*ut+(O-W)*ht}const lt={random(){return y.setup({adapter:D,strategy:at,options:void 0})},alphaBeta(r){const t={maxDepth:r.maxDepth??4,quiescence:r.quiescence??!0,evaluationFunction:r.evaluationFunction??it};return y.setup({adapter:D,strategy:rt,options:t})}};exports.EnglishDraughts=nt;exports.EnglishDraughtsBitSquare=a;exports.EnglishDraughtsComputerFactory=lt;exports.EnglishDraughtsEngineFactory=T;
    `;
    
    // Simula require para o rapid-draughts
    function require(path) {
        if (path === "./index-cMcgHLGu.cjs") {
            return {
                DraughtsEngine: class DraughtsEngine {
                    constructor(data, methods) {
                        this.data = data;
                        this.methods = methods;
                    }
                    get status() { return this.methods.status(this); }
                    get moves() { return this.methods.moves(this); }
                    isValidMove(move) { return this.methods.isValidMove(this, move); }
                    move(move) { 
                        this.data = this.methods.move(this, move);
                    }
                    clone() {
                        return new DraughtsEngine({...this.data}, this.methods);
                    }
                },
                DraughtsPlayer: {
                    LIGHT: 1,
                    DARK: 2
                },
                DraughtsStatus: {
                    PLAYING: 0,
                    LIGHT_WON: 1,
                    DARK_WON: 2,
                    DRAW: 3
                }
            };
        }
        return {};
    }
    
    // Executa o código do rapid-draughts
    eval(rapidDraughtsCode);
    
    // Expõe no window
    window.EnglishDraughts = module.exports.EnglishDraughts;
    window.EnglishDraughtsComputerFactory = module.exports.EnglishDraughtsComputerFactory;
    
    console.log('✅ Rapid-draughts carregado no window:', {
        EnglishDraughts: typeof window.EnglishDraughts,
        EnglishDraughtsComputerFactory: typeof window.EnglishDraughtsComputerFactory
    });
})();
